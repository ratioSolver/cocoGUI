<template>
  <v-container v-resize='on_resize' class="h-75" :id='get_graph_id(solver)' fluid />
</template>

<script setup lang="ts">
import { Solver, SolverListener, Flaw, Resolver } from '@/solver';
import { nextTick, onUnmounted } from 'vue';
import cytoscape from 'cytoscape';
import dagre from 'cytoscape-dagre';
import popper from 'cytoscape-popper';
import chroma from 'chroma-js';
import tippy from 'tippy.js';
import 'tippy.js/themes/light-border.css';

const scale = chroma.scale(['#0f0', '#f00']).mode('lrgb').domain([0, 15]);

const props = defineProps<{ solver: Solver; }>();

const get_graph_id = (solver: Solver) => 'slv-' + solver.id + '-graph';

cytoscape.use(dagre);
cytoscape.use(popper);

let listener: SolverListenerImpl | null = null;

tippy.setDefaultProps({
  arrow: false,
  trigger: 'manual',
  theme: 'light-border',
  placement: 'bottom'
});

class SolverListenerImpl extends SolverListener {

  cy: cytoscape.Core;
  layout = {
    name: 'dagre',
    rankDir: 'LR',
    fit: false,
    nodeDimensionsIncludeLabels: true
  };


  constructor(solver: Solver) {
    super();

    this.cy = cytoscape({
      container: document.getElementById(get_graph_id(solver)),
      style: [
        {
          selector: 'node[type="flaw"]',
          style: {
            'shape': 'round-rectangle',
            'background-color': 'data(color)',
            'label': 'data(label)',
            'border-width': '1px',
            'border-style': 'data(stroke)',
            'border-color': '#666'
          }
        },
        {
          selector: 'node[type="resolver"]',
          style: {
            'shape': 'ellipse',
            'background-color': 'data(color)',
            'label': 'data(label)',
            'border-width': '1px',
            'border-style': 'data(stroke)',
            'border-color': '#666'
          }
        },
        {
          selector: 'edge',
          style: {
            'curve-style': 'bezier',
            'line-color': '#666',
            'target-arrow-color': '#666',
            'target-arrow-shape': 'triangle',
            'width': '1px',
            'line-style': 'data(stroke)'
          }
        },
        {
          selector: '.current',
          style: {
            'border-width': '3px',
            'border-color': '#000'
          }
        }
      ]
    });

    solver.add_listener(this);
  }

  graph(graph: { flaws: Flaw[], resolvers: Resolver[], current_flaw: Flaw, current_resolver: Resolver }): void {
    this.cy.elements().remove();
    for (const flaw of graph.flaws) {
      const n = this.cy.add({ group: 'nodes', data: { id: flaw.id, type: 'flaw', label: Flaw.flaw_label(flaw), state: flaw.state, cost: flaw.cost, color: flaw.cost < Number.POSITIVE_INFINITY ? scale(flaw.cost).hex() : '#ccc', stroke: stroke_style(flaw) } });
      n.tippy = tippy(document.createElement('div'), { getReferenceClientRect: n.popperRef().getBoundingClientRect, content: Flaw.flaw_tooltip(flaw), });
      n.on('mouseover', () => n.tippy.show());
      n.on('mouseout', () => n.tippy.hide());
    }
    for (const resolver of graph.resolvers) {
      const n = this.cy.add({ group: 'nodes', data: { id: resolver.id, type: 'resolver', label: Resolver.resolver_label(resolver), state: resolver.state, cost: resolver.cost, color: resolver.cost < Number.POSITIVE_INFINITY ? scale(resolver.cost).hex() : '#ccc', stroke: stroke_style(resolver) } });
      n.tippy = tippy(document.createElement('div'), { getReferenceClientRect: n.popperRef().getBoundingClientRect, content: Resolver.resolver_tooltip(resolver), });
      n.on('mouseover', () => n.tippy.show());
      n.on('mouseout', () => n.tippy.hide());
      this.cy.add({ group: 'edges', data: { id: resolver.id + '-' + resolver.flaw.id, source: resolver.id, target: resolver.flaw.id, state: resolver.state, stroke: stroke_style(resolver) } });
      for (const precondition of resolver.preconditions)
        this.cy.add({ group: 'edges', data: { id: precondition + '-' + resolver.id, source: precondition, target: resolver.id, state: resolver.state, stroke: stroke_style(resolver) } });
    }
    this.cy.layout(this.layout).run();
  }
  flaw_created(flaw: Flaw) {
    const n = this.cy.add({ group: 'nodes', data: { id: flaw.id, type: 'flaw', label: Flaw.flaw_label(flaw), state: flaw.state, cost: flaw.cost, color: flaw.cost < Number.POSITIVE_INFINITY ? scale(flaw.cost).hex() : '#ccc', stroke: stroke_style(flaw) } });
    n.tippy = tippy(document.createElement('div'), { getReferenceClientRect: n.popperRef().getBoundingClientRect, content: Flaw.flaw_tooltip(flaw), });
    n.on('mouseover', () => n.tippy.show());
    n.on('mouseout', () => n.tippy.hide());
    this.cy.layout(this.layout).run();
  }
  flaw_state_changed(flaw: Flaw) {
    this.cy.$id(flaw.id).data({ state: flaw.state, stroke: stroke_style(flaw) });
  }
  flaw_cost_changed(flaw: Flaw) {
    this.cy.$id(flaw.id).data({ cost: flaw.cost, color: flaw.cost < Number.POSITIVE_INFINITY ? scale(flaw.cost).hex() : '#ccc' });
  }
  flaw_position_changed(flaw: Flaw) {
    this.cy.$id(flaw.id).tippy.setContent(Flaw.flaw_tooltip(flaw));
  }
  current_flaw_changed(flaw: Flaw) {
    if (flaw.current)
      this.cy.$id(flaw.id).addClass('current');
    else
      this.cy.$id(flaw.id).removeClass('current');
  }
  resolver_created(resolver: Resolver) {
    const n = this.cy.add({ group: 'nodes', data: { id: resolver.id, type: 'resolver', label: Resolver.resolver_label(resolver), state: resolver.state, cost: resolver.cost, color: resolver.cost < Number.POSITIVE_INFINITY ? scale(resolver.cost).hex() : '#ccc', stroke: stroke_style(resolver) } });
    n.tippy = tippy(document.createElement('div'), { getReferenceClientRect: n.popperRef().getBoundingClientRect, content: Resolver.resolver_tooltip(resolver), });
    n.on('mouseover', () => n.tippy.show());
    n.on('mouseout', () => n.tippy.hide());
    this.cy.add({ group: 'edges', data: { id: resolver.id + '-' + resolver.flaw.id, source: resolver.id, target: resolver.flaw.id, state: resolver.state, stroke: stroke_style(resolver) } });
    for (const precondition of resolver.preconditions)
      this.cy.add({ group: 'edges', data: { id: precondition + '-' + resolver.id, source: precondition, target: resolver.id, state: resolver.state, stroke: stroke_style(resolver) } });
    this.cy.layout(this.layout).run();
  }
  resolver_state_changed(resolver: Resolver) {
    this.cy.$id(resolver.id).data({ state: resolver.state, stroke: stroke_style(resolver) });
    this.cy.$id(resolver.id + '-' + resolver.flaw.id).data({ state: resolver.state, stroke: stroke_style(resolver) });
    for (const precondition of resolver.preconditions)
      this.cy.$id(precondition + '-' + resolver.id).data({ state: resolver.state, stroke: stroke_style(resolver) });
  }
  resolver_cost_changed(resolver: Resolver) {
    this.cy.$id(resolver.id).data({ cost: resolver.cost, color: resolver.cost < Number.POSITIVE_INFINITY ? scale(resolver.cost).hex() : '#ccc' });
  }
  current_resolver_changed(resolver: Resolver) {
    if (resolver.current)
      this.cy.$id(resolver.id).addClass('current');
    else
      this.cy.$id(resolver.id).removeClass('current');
  }
  causal_link_added(flaw: Flaw, resolver: Resolver) {
    this.cy.add({ group: 'edges', data: { id: flaw.id + '-' + resolver.id, source: flaw.id, target: resolver.id, state: resolver.state, stroke: stroke_style(resolver) } });
    this.cy.layout(this.layout).run();
  }
}

onUnmounted(() => {
  props.solver.remove_listener(listener!);
  listener!.cy.destroy();
  listener = null;
});

function on_resize() {
  nextTick(() => {
    if (listener)
      listener.cy.resize();
    else if (document.getElementById(get_graph_id(props.solver))!.offsetWidth && document.getElementById(get_graph_id(props.solver))!.offsetHeight)
      listener = new SolverListenerImpl(props.solver);
  });
}
</script>

<script>
function stroke_style(node: Flaw | Resolver) {
  switch (node.state) {
    case 'forbidden':
      return 'dotted';
    case 'active':
      return 'solid';
    case 'inactive':
      return 'dashed';
  }
}
</script>